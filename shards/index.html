<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <title>What Are Splinter Logic Shards? - Splinter Vector KV Substrate</title>
    <meta name="color-scheme" content="dark">
    <meta name="google-site-verification" content="cFJqGxOZGxw1APr0yrQthB4Ml5vFuMNBu39xMS4BYJI">
    <link rel="stylesheet" media="(prefers-color-scheme:dark)" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.20.1/cdn/themes/dark.css" onload="document.documentElement.classList.add('sl-theme-dark');">
    <link rel="stylesheet" href="/style.css">
    <link rel="canonical" href="https://splinterhq.github.io/shards/">
    <script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js">
    </script>
  <meta property="og:type" content="website">
<meta property="og:site_name" content="Splinter Vector KV Substrate">
<meta property="og:locale" content="en">
<meta property="og:description" content="Learn about Splinter Logic Shards, loadable modules that allow dynamic extension of the CLI architecture for custom data processing and transformation.">
<meta property="og:url" content="https://splinterhq.github.io/shards/">
<meta property="og:image" content="https://splinterhq.github.io/uploads/favicon.svg">
<meta name="twitter:card" content="summary">
<meta name="description" content="Learn about Splinter Logic Shards, loadable modules that allow dynamic extension of the CLI architecture for custom data processing and transformation.">
<meta name="keywords" content="Logic Shards, Loadable Modules, Dynamic Extension, C Plugins, Data Transformation">
<meta name="robots" content="index, follow">
<meta name="generator" content="Lume 3.1.1">
<link rel="icon" sizes="32x32" href="/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" sizes="any" href="/uploads/favicon.svg" type="image/svg+xml">
</head>
  <body>
    <main class="container">
      <nav class="top-nav" id="nav">
        <a href="/">INTRO</a>
        <a href="/core">CORE</a>
        <a href="/cli">CLI</a>
        <a href="/shards">SHARDS</a>
        <a href="/bindings">BINDINGS</a>
        <a href="https://github.com/splinterhq/libsplinter/tree/main" target="_blank">CODE</a>
      </nav>
      <div style="clear: both"></div>
      <h1>What Are Splinter Logic Shards?</h1>
<p>Splinter's CLI is easily extended, but, you might want to link against
<em>considerably more</em> than Splinter's build system allows for, and it's usually
just for one or several very specific tasks.</p>
<p>In short, you need to be able to load modules into the CLI architecture that can
handle your custom processing, transformation, observation, <em><strong>whatever</strong></em>
without having to wrangle linkage and that didn't need to be located in-tree to
be compiled.</p>
<p>If you want to develop a <code>foo</code> command, you should be able to just do so and
point <code>splinterctl</code> or <code>splinter_cli</code> at the <code>.so</code> file and, provided it
conforms to a symbol map, loads it.</p>
<p>This gives you access to Splinter with all the CLI structure and whatever else
you want to bring in, without having to modify Splinter or the tools.</p>
<h2>The Solution: Loadable Shards (a type-punned derivative of a "splinter" ü§ì)</h2>
<p>Design constraints prevent making the CLI's module list dynamic; some
platforms disallow heap allocation entirely so Splinter tries hard to not
require it for anything essential, even in tooling.</p>
<p>We need to instead have an optional dynamic module structure that can advertise
and enter these 'shards' for the user. As long as they contain the correct entry
points and metadata, they can be compiled anywhere <code>splinter.h</code> can be found.
This <code>splinter_shard_t</code> will be the only coupling of tooling to the core store
(found in the core header, not CLI).</p>
<h2>Progress: Figured Out Mostly and Coming Soon!</h2>
<p>Implementation requires a little juggling of what the CLI currently understands
a use session to look like as far as different users loading different shards
that have the same topological access to the same store.</p>
<p>There's some memory expectation setting and accounting to tackle as shards load
and prepare workloads that might compete with each other, or send the kernel
conflicting signals when it comes to the same region of memory.</p>
<p>I'm going to add store level accounting bits so that shards cooperatively schedule
themselves based on how they need to use memory for how long and at what scheduling
priority. This election determines what shards run when, and what is ultimately
communicated to the kernel via <code>posix_madvise()</code>.</p>
<p>Shards will use a <code>splinter_madvise()</code> that votes in the election, and can optionally
block instead of voluntarily yielding, depending on what kind of API is being
called.</p>
<p><strong>Put plainly:</strong> The kernel can't be put in a state where it has to constantly
re-evaluate its page cache strategy for the same region just because a cron job was
ill-conceived, but we need "quick and sometimes dirty load-ables" for experiments
or production inference loads. Shards are a great compromise answer.</p>
<p>The shape of the helpers / macros is still wildly kinetic, but functionality and
design have been mostly finalized. CPU use intent is also being factored in.</p>
<p>Shards are expected to 'land' sometime in March 2026.</p>
<h2>What Can We *DO* With Them, Though?!</h2>
<p>Practical examples would be sidecar analysis, sidecar inference, backfill, a shard
could even expose the store as a RESTful interface. <code>splinference.cpp</code> is an example
of running a llama.cpp style inference loop without sockets or moving memory around;
it would be even more valuable as a loadable object that could be run on-demand in
the CLI. Shards can service signal groups with whatever you need them to do right after
your data lands.</p>
<p>Think what you could do with something like <a href="https://github.com/bytedance/sonic">Sonic</a>
in a sidecar serializing your data asynchronously without socket, mutex
or even <code>memcpy()</code> penalty. You can write shards in Go, Rust, or any
language that compiles down to standard shared objects.</p>
<p>Shards have access to Lua, too <code>:)</code></p>
<p>Stay tuned!</p>

    </main>
    <footer>
    Want To Help Fund Development?<br>
    <div style="text-align: center; margin: 1em auto">
      <a href="https://www.buymeacoffee.com/timthepost" id="donateLink" target="_blank">
        <img src="https://cdn.buymeacoffee.com/buttons/v2/default-blue.png" alt="Buy Me A Coffee" title="I run on coffee!" style="height: 60px !important; width: 217px !important">
      </a>
    </div>
    Built BBS Ugly ‚ù§Ô∏è With BBS Love<br>
    </footer>
  

</body></html>